<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux玩转计划</title>
      <link href="/2023/05/15/Linux%E7%8E%A9%E8%BD%AC%E8%AE%A1%E5%88%92/"/>
      <url>/2023/05/15/Linux%E7%8E%A9%E8%BD%AC%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p>学习了 Linux 的一堆命令行，但没有什么练习的场景，打算给自己挖坑并不断填坑，逐渐将   Linux 的内容能玩转起来。在挖坑填坑的同时做一些记录。</p><h3 id="2023-x2F-5-x2F-15"><a href="#2023-x2F-5-x2F-15" class="headerlink" title="2023&#x2F;5&#x2F;15"></a>2023&#x2F;5&#x2F;15</h3><ul><li>下载 vscode，配置好 C&#x2F;C++ 环境。</li><li>下载 Chrome，QQ，Pycharm </li><li>通关一款 vim 小游戏</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习笔记</title>
      <link href="/2023/05/13/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/05/13/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="0-环境配置"><a href="#0-环境配置" class="headerlink" title="0. 环境配置"></a>0. 环境配置</h3><p> 配置一个 Linux 环境，我们需要先安装一个虚拟机，然后在虚拟机上面安装一个 Linux 系统来学习</p><ul><li>安装 virtual machine</li><li>在 vm 中安装 Linux（这里使用的是 CentOS 7）</li></ul><p>具体的环境安装教程：</p><p><a href="https://www.bilibili.com/video/BV1Sv411r7vd?p=5&vd_source=f72255f45500a180dd6d14464b11487b">【小白入门 通俗易懂】2021韩顺平 一周学会Linux</a></p><h3 id="1-虚拟机相关操作"><a href="#1-虚拟机相关操作" class="headerlink" title="1. 虚拟机相关操作"></a>1. 虚拟机相关操作</h3><h4 id="1-1-虚拟机克隆"><a href="#1-1-虚拟机克隆" class="headerlink" title="1.1 虚拟机克隆"></a>1.1 虚拟机克隆</h4><p>如果已经安装好了一个 Linux 系统，没有必要重新安装，只需要进行克隆即可，有两种方法：</p><ul><li>直接拷贝一份安装好的虚拟机文件</li><li>使用 vmware 的克隆操作，<strong>克隆时需要关闭 Linux 系统</strong></li></ul><p>这里放一个链接，以后需要克隆操作了来这里就行</p><p><a href="https://blog.csdn.net/awd15771131554/article/details/123778655?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167161482716800211569948%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167161482716800211569948&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-123778655-null-null.142%5Ev68%5Ewechat_v2,201%5Ev4%5Eadd_ask,213%5Ev2%5Et3_control1&utm_term=%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%85%8B%E9%9A%86&spm=1018.2226.3001.4187">虚拟机克隆的两种方式</a></p><h4 id="1-2-虚拟机快照"><a href="#1-2-虚拟机快照" class="headerlink" title="1.2 虚拟机快照"></a>1.2 虚拟机快照</h4><p>在使用虚拟机系统的时候，如果想要回到原先的某一个状态，就可以使用<strong>虚拟机快照</strong>。</p><p>虚拟机快照暂时用不上，这里先空着</p><h4 id="1-3-vmtools"><a href="#1-3-vmtools" class="headerlink" title="1.3 vmtools"></a>1.3 vmtools</h4><p>vmtools 是为了让我们在 windows 下更好地管理虚拟机，可以<strong>设置 windows 和 Linux 的共享文件夹</strong></p><p><img src="/2023/05/13/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221221173727524.png" alt="image-20221221173727524"></p><p>至于使用教程，看<a href="https://www.bilibili.com/video/BV1Sv411r7vd?p=5&vd_source=f72255f45500a180dd6d14464b11487b">【小白入门 通俗易懂】2021韩顺平 一周学会Linux</a></p><h3 id="2-Linux目录结构"><a href="#2-Linux目录结构" class="headerlink" title="2. Linux目录结构"></a>2. Linux目录结构</h3><h4 id="2-1-基本介绍"><a href="#2-1-基本介绍" class="headerlink" title="2.1 基本介绍"></a>2.1 基本介绍</h4><p>Linux 的文件系统采用的是层级式的树状目录结构，在此结构中最上层的是根目录<code>/</code>，然后在此目录下创建其他目录。</p><p><strong>在Linux世界里，一切对象皆文件！</strong></p><p><img src="https://www.runoob.com/wp-content/uploads/2014/06/d0c50-linux2bfile2bsystem2bhierarchy.jpg" alt="Linux 系统目录结构| 菜鸟教程"></p><h4 id="2-2-具体目录结构"><a href="#2-2-具体目录结构" class="headerlink" title="2.2 具体目录结构"></a>2.2 具体目录结构</h4><p>许多目录了解即可，使用多了就熟了</p><ul><li><p><code>/bin</code></p><p>Binary 的缩写，存放经常使用的命令</p></li><li><p><code>/sbin</code></p><p>s 表示 Super user，存放系统管理员使用的系统管理程序</p></li><li><p><code>/home</code></p><p>存放普通用户的主目录，在 Linux 中每个用户都有一个自己的目录，且目录名是用户名</p></li><li><p><code>/root</code></p><p>该目录为系统管理员，即超级权限者的用户主目录</p></li><li><p><code>/lib</code></p><p>系统开机所需要的最基本的动态连接共享库，类似于 Win 里的 DLL 文件。</p></li><li><p><code>/lost+found</code></p><p>该目录一般是空的，当系统非法关机后，这里面存放了一些文件</p></li><li><p><code>/etc</code></p><p>所有的系统管理所需要的配置文件和子目录</p></li><li><p><code>/usr</code></p><p>用户的很多应用程序和文件都存放在该目录下</p></li><li><p><code>/boot</code></p><p>存放启动 Linux 时的一些核心文件，包括一些连接文件以及镜像文件</p></li><li><p><code>/proc</code></p><p>这是一个虚拟的目录，是系统内存的映射，访问这个目录来获取系统的信息</p></li><li><p><code>/srv</code></p><p>service 的缩写，存放一些服务启动之后需要提取的数据</p></li><li><p><code>/sys</code></p><p>安装了内核中新出现的一个文件系统</p></li><li><p><code>/tmp</code></p><p>存放一些临时文件</p></li><li><p><code>/dev</code></p><p>类似于 Win 的设备管理器，把所有的硬件用文件的形式存储</p></li><li><p><code>/media</code></p><p>Linux 系统会自动识别一些设备，例如 U盘、光驱等，识别后，会以文件的形式挂载到这个目录下</p></li><li><p><code>/mnt</code></p><p>让用户临时挂载别的文件系统，就是之前提到的共享文件夹所在位置</p></li><li><p><code>/opt</code></p><p>给主机额外安装软件所存放的目录</p></li><li><p><code>/usr/local</code></p><p>这是另一个给主机额外安装软件所安装的目录</p></li><li><p><code>/var</code></p><p>存放着不断扩充的东西，习惯将经常被修改的目录放在这里</p></li><li><p><code>/selinux</code> [security-enhanced linux]</p><p>安全子系统</p></li></ul><h4 id="2-3-Linux命令格式"><a href="#2-3-Linux命令格式" class="headerlink" title="2.3 Linux命令格式"></a>2.3 Linux命令格式</h4><p>Linux 命令一般由三个部分组成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command [-options] [parameter]</span><br></pre></td></tr></table></figure><p>command 表示命令，必须存在；后面分别是选项和参数，可有可无。</p><h3 id="3-远程登录"><a href="#3-远程登录" class="headerlink" title="3. 远程登录"></a>3. 远程登录</h3><p>在实际项目中，没有 Linux 图形化的用户界面，对 Linux 的操作都是通过远程操作的，常用的工具有<strong>Xshell和Xftp</strong>，前者通过命令行形式对 Linux 进行操作；后者则进行一些文件的交换。</p><p><img src="/2023/05/13/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221221181122404.png" alt="image-20221221181122404"></p><p>至于具体操作，看视频吧</p><h3 id="4-Vi和Vim编辑器"><a href="#4-Vi和Vim编辑器" class="headerlink" title="4. Vi和Vim编辑器"></a>4. Vi和Vim编辑器</h3><p>Vi 是 Linux 内置的文本编辑器，而 Vim 具有程序编辑能力，可以看作是 Vi 的增强版本。</p><p><strong>如何进入Vim</strong></p><p><code>vim 文件名</code>，如果文件名存在则打开现有文件；不存在就创建新文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim xxx.py</span><br></pre></td></tr></table></figure><h4 id="4-1-三种模式"><a href="#4-1-三种模式" class="headerlink" title="4.1 三种模式"></a>4.1 三种模式</h4><ul><li><p><strong>正常模式</strong></p><p>也称一般模式，是刚进入编辑器的默认模式。可以用【上下左右】来移动光标，也可以删除字符、删除整行；复制、粘贴来处理文件数据；可以定位行数</p></li><li><p><strong>插入模式</strong></p><p>按下<code>i,I,o,O,a,A,r,R</code>其中任意一个字母即可进入插入模式，一般来说按 i 即可，该模式主要对文本进行编辑</p></li><li><p><strong>命令行模式</strong></p><p>按下<code>Esc</code>再输入<code>:</code>，进入命令行模式，可以完成读取，保存，离开 vim，显示行号等操作</p></li></ul><p>下面是各种模式相互切换图：</p><p><img src="/2023/05/13/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221222094333426.png" alt="image-20221222094333426"></p><h4 id="4-2-快捷键使用"><a href="#4-2-快捷键使用" class="headerlink" title="4.2 快捷键使用"></a>4.2 快捷键使用</h4><p>由于快捷键很多，这里只列几个常用的，最后附一张快捷键大全键盘表</p><ul><li>拷贝当前行：<code>yy</code>，拷贝当前行向下的5行：<code>5yy</code>，并粘贴：<code>p</code>（paste）</li><li>删除当前行：<code>dd</code>，删除当前行向下的5行：<code>5dd</code></li><li>查找某个单词，在命令行模式下：<code>/关键字</code>，回车查找，输入<code>n</code>表示查找下一个</li><li>显示行号【命令行模式】：<code>set nu</code>，隐藏行号：<code>set nonu</code></li><li>光标跳转【一般模式】，到最末行：<code>G</code>，到最首行：<code>gg</code>，将光标移动到目标行：先输入一个数字（要跳转的行数），在 shift+g</li><li>动作撤销【一般模式】：<code>u</code></li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2015/10/vi-vim-cheat-sheet-sch1.gif" alt="vi-vim-cheat-sheet-sch"></p><h3 id="5-关机-重启-用户登录注销"><a href="#5-关机-重启-用户登录注销" class="headerlink" title="5. 关机 重启 用户登录注销"></a>5. 关机 重启 用户登录注销</h3><h4 id="5-1-关机-amp-重启指令"><a href="#5-1-关机-amp-重启指令" class="headerlink" title="5.1 关机&amp;重启指令"></a>5.1 关机&amp;重启指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shutdown -h now //立即进行关机</span><br><span class="line">shutdown -h 1//1分钟后自动关机</span><br><span class="line">shutdown -r now//立即重启计算机</span><br><span class="line">halt//立即关机</span><br><span class="line">reboot//立即重启</span><br><span class="line">sync//把内存的数据同步到磁盘</span><br></pre></td></tr></table></figure><p><strong>注</strong>：上面介绍的关机和重启命令均已经进行了 sync，但为了保险起见，还是先主动执行一次 sync，再关机或重启</p><h4 id="5-2-用户登录和注销"><a href="#5-2-用户登录和注销" class="headerlink" title="5.2 用户登录和注销"></a>5.2 用户登录和注销</h4><p>root用户是系统管理员，有最大的权限。一般使用普通用户登录，<code>su - 用户名</code>，root切换到普通用户不需要输入密码，但相反则需要输入密码</p><p>若要注销用户，使用 <code>logout</code>，则会退回到上一个用户，直到所有用户都注销完。注意，<strong>该指令在图形运行级别无效，在运行级别 3 下有效</strong>，运行级别的概念之后会介绍</p><h3 id="6-用户管理"><a href="#6-用户管理" class="headerlink" title="6. 用户管理"></a>6. 用户管理</h3><p>Linux 系统是一个多用户多任务的操作系统，任何一个想要使用系统资源的用户，都必须先向系统管理员申请一个账号，然后以这个账号的身份进入系统</p><h4 id="6-1-添加用户"><a href="#6-1-添加用户" class="headerlink" title="6.1 添加用户"></a>6.1 添加用户</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd cherry//创建了一个名为cherry的用户</span><br><span class="line">useradd -d 指定目录 用户名</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>第一种方法创建的用户默认放在了 &#x2F;home&#x2F;cherry 文件夹下</li><li>如果要指定用户的目录位置，则用第二种方法</li></ul><h4 id="6-2-修改密码"><a href="#6-2-修改密码" class="headerlink" title="6.2 修改密码"></a>6.2 修改密码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd cherry</span><br></pre></td></tr></table></figure><p>给 cherry 指定密码，执行完上述指令后，输入密码即可</p><p>补充：显示当前用户所在的目录：<code>pwd</code></p><h4 id="6-3-删除用户"><a href="#6-3-删除用户" class="headerlink" title="6.3 删除用户"></a>6.3 删除用户</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userdel cherry</span><br><span class="line">userdel -r cherry</span><br></pre></td></tr></table></figure><ul><li>第一种方法删除 cherry 用户，但保留了用户主目录，即 &#x2F;home&#x2F;cherry，这是为了保留里面的文件</li><li>第二种方法同时删除了用户主目录</li></ul><p><strong>一般建议保留用户主目录</strong></p><h4 id="6-4-查询用户信息"><a href="#6-4-查询用户信息" class="headerlink" title="6.4 查询用户信息"></a>6.4 查询用户信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id cherry</span><br><span class="line">id root</span><br></pre></td></tr></table></figure><p>当用户不存在时，返回无此用户</p><h4 id="6-5-切换用户"><a href="#6-5-切换用户" class="headerlink" title="6.5 切换用户"></a>6.5 切换用户</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su - cherry</span><br><span class="line">su - root</span><br></pre></td></tr></table></figure><p>正如前面提到，root 切换到 cherry 不需要密码，但反过来则需要输入密码</p><p>当返回到上一个用户时，使用<code>exit</code>或<code>logout</code></p><h4 id="6-6-查看用户"><a href="#6-6-查看用户" class="headerlink" title="6.6 查看用户"></a>6.6 查看用户</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br><span class="line">who am i</span><br></pre></td></tr></table></figure><p>注意，第一个指令显示当前用户的名字，而第二个指令显示最开始用户的名字和登录时间等信息。</p><h4 id="6-7-用户组"><a href="#6-7-用户组" class="headerlink" title="6.7 用户组"></a>6.7 用户组</h4><p>设置用户组，可以同时对多个用户进行统一管理</p><h5 id="6-7-1-新增-x2F-删除"><a href="#6-7-1-新增-x2F-删除" class="headerlink" title="6.7.1 新增&#x2F;删除"></a>6.7.1 新增&#x2F;删除</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd 组名</span><br><span class="line">groupdel 组名</span><br></pre></td></tr></table></figure><h5 id="6-7-2-指定用户的组"><a href="#6-7-2-指定用户的组" class="headerlink" title="6.7.2 指定用户的组"></a>6.7.2 指定用户的组</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd -g 用户组 用户名</span><br><span class="line">usermod -g 用户组 用户名</span><br></pre></td></tr></table></figure><ul><li>前者是在创建用户的之后直接给用户分配到一个组中</li><li>后者则是修改已有的用户所在的组</li></ul><p>注：当创建一个用户但没有给他分配组时，其用户名就是一个用户组</p><h4 id="6-8-用户和组相关文件"><a href="#6-8-用户和组相关文件" class="headerlink" title="6.8 用户和组相关文件"></a>6.8 用户和组相关文件</h4><ul><li><p><code>/etc/passwd</code></p><p>用户的配置文件，记录用户的各种信息</p></li><li><p><code>/etc/shadow</code></p><p>口令的配置文件</p></li><li><p><code>/etc/group</code></p><p>组的配置文件</p></li></ul><h3 id="7-实用指令"><a href="#7-实用指令" class="headerlink" title="7. 实用指令"></a>7. 实用指令</h3><h4 id="7-1-运行级别"><a href="#7-1-运行级别" class="headerlink" title="7.1 运行级别"></a>7.1 运行级别</h4><p>Linux 有许多种运行级别</p><ul><li><p>0：关机</p></li><li><p>1：单用户（可以找回丢失密码）</p><p>至于找回丢失密码具体操作详见教程</p></li><li><p>2：多用户状态无网络服务</p></li><li><p>3：多用户状态有网络服务</p></li><li><p>4：系统未使用保留给用户</p></li><li><p>5：图形界面</p></li><li><p>6：系统重启</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init 3//切换到运行级别3</span><br></pre></td></tr></table></figure><p>在 Centos 中进行了简化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl get-default//获取当前运行级别</span><br><span class="line">systemctl set-default multi-user.target//设置为运行级别3</span><br><span class="line">systemctl set-default graphical.target//设置为运行级别5</span><br></pre></td></tr></table></figure><h4 id="7-2-帮助指令"><a href="#7-2-帮助指令" class="headerlink" title="7.2 帮助指令"></a>7.2 帮助指令</h4><ul><li><p><code>man</code>获得帮助信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man ls//查看ls命令的帮助信息</span><br></pre></td></tr></table></figure></li><li><p><code>help</code>获得shell内置命令的帮助信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">help cd//查看cd命令的帮助信息</span><br></pre></td></tr></table></figure></li></ul><h4 id="7-3-文件目录"><a href="#7-3-文件目录" class="headerlink" title="7.3 文件目录"></a>7.3 文件目录</h4><p>在介绍文件目录前，先补充一下绝对路径和相对路径的概念。</p><p>Linux 下的根目录为 <code>/</code> ，从这里出发寻找文件，则是绝对路径。</p><p>而如果想使用相对路径，一个点 <code>.</code> 表示当前路径，两个点 <code>..</code> 表示当前路径的上一个路径，<code>../..</code> 表示上上一个路径，依此类推。</p><ol><li><p><code>pwd</code>指令</p><p>print working directory 显示当前工作目录的绝对路径</p></li><li><p><code>ls</code>指令</p><p>list</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls//显示当前目录包含的文件和目录</span><br><span class="line">ls -a//隐藏的也显示出来</span><br><span class="line">ls -l//以列表方式显示</span><br><span class="line">ls -al//a和l也可以组合使用</span><br></pre></td></tr></table></figure></li><li><p><code>cd</code>指令</p><p>change directory 切换到指定目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd ~//回到自己的家目录</span><br><span class="line">cd /root//【绝对路径】切换到/root</span><br><span class="line">cd ..//切换到上一级目录</span><br><span class="line">//如果此时在家目录home</span><br><span class="line">cd /cherry//【相对路径】切换到/home/cherry</span><br></pre></td></tr></table></figure></li><li><p><code>mkdir</code>指令</p><p>make directory 创建新的目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /home/dog//在home目录下创建dog</span><br><span class="line">mkdir -p /home/animal/dog//创建多级目录</span><br></pre></td></tr></table></figure><p>这里对创建多级目录多做一点解释，本身是没有 &#x2F;animal 目录的，现在要在 &#x2F;animal 下创建 &#x2F;dog，因此称为创建多级目录</p></li><li><p><code>rmdir</code>指令</p><p>remove directory 删除空目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir /home/dog</span><br></pre></td></tr></table></figure><p>此条指令只能删除空目录，如果该目录下有内容是无法删除的</p></li><li><p><code>touch</code>指令</p><p>创建新文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch hello.py//在当前目录下创建文件</span><br><span class="line">touch /home/hello.py//在指定目录下创建文件</span><br></pre></td></tr></table></figure></li><li><p><code>cp</code>指令</p><p>拷贝文件到指定目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp /home/hello.txt /home/bbb//将home下的hello.txt文件拷贝到home/bbb目录里</span><br><span class="line">cp -r /home/bbb /opt//将home/bbb文件夹递归地拷贝到/opt下</span><br></pre></td></tr></table></figure><p>递归地拷贝即该文件夹包括里面所有内容都拷贝</p><p>强制覆盖不提示方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\cp -r /home/bbb /opt</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -rfd dir_a dir_b</span><br></pre></td></tr></table></figure><ul><li>r：recursive，递归地，即复制所有文件。</li><li>f：force，强制覆盖。</li><li>d：如果源文件为链接文件，也只是把它作为链接文件复制过去，而不是复制实际文件。</li></ul></li><li><p><code>rm</code>指令</p><p>remove 移除文件或目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rm /home/hello.py//删除hello.py</span><br><span class="line">rm -r /home/dog//递归地删除整个文件夹</span><br><span class="line">rm -f /home/hello.py//强制删除不提示</span><br><span class="line">rm -rf /home/dog//递归地删除dog文件夹且不提示</span><br></pre></td></tr></table></figure></li><li><p><code>mv</code>指令</p><p>移动文件与目录或重命名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv oldNameFile newNameFile</span><br><span class="line">mv /temp/movefile /targetFolder</span><br></pre></td></tr></table></figure></li><li><p><code>cat</code>指令</p><p>查看文件内容，是一种比 Vim 更安全的一种查看内容的方式，因为cat是只读模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /home/hello.py</span><br><span class="line">cat -n /home/hello.py  //显示行号</span><br><span class="line">cat -n /home/hello.py | more</span><br></pre></td></tr></table></figure><p>第三行的more为管道命令</p></li><li><p><code>more</code>指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more 要查看的文件</span><br></pre></td></tr></table></figure><p><img src="/2023/05/13/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221223161945515.png" alt="image-20221223161945515"></p></li><li><p><code>less</code>指令</p><p>比more更强大，支持各种显示终端。更特别的是，less 在显示文件内容时，并不是一次性将整个文件加载完才显示，而是根据显示需要加载的内容，对于大型文件具有更高的效率</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less 要查看的文件</span><br></pre></td></tr></table></figure><p><img src="/2023/05/13/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221223172227171.png" alt="image-20221223172227171"></p></li><li><p><code>echo</code>指令</p><p>echo 输出内容到控制台，可以输出环境变量等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;Hello, world!&quot;</span><br></pre></td></tr></table></figure></li><li><p><code>head</code>指令</p><p>显示文件开头的部分内容，默认情况下 head 指令显示文件的前10行内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">head filename</span><br><span class="line">head -n 5 filename//查看文件前面5行内容</span><br></pre></td></tr></table></figure></li><li><p><code>tail</code>指令</p><p>和 head 类似，输出尾部的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tail filename</span><br><span class="line">tail -n 5 filename //查看文件尾5行内容</span><br><span class="line">tail -f filename//实时追踪该文档的所有更新</span><br></pre></td></tr></table></figure></li><li><p><code>&gt;</code>和<code>&gt;&gt;</code>指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls -l &gt; filename//列表的内容写入filename中(覆盖写)</span><br><span class="line">ls -l &gt; filename //列表的内容写入filename中(追加写)</span><br><span class="line">cat file1 &gt; file2//将文件1的内容写入文件2</span><br><span class="line">echo &quot;echo&quot; &gt;&gt; file</span><br><span class="line">cal &gt;&gt; info.txt//日历信息追加到info.txt中</span><br></pre></td></tr></table></figure></li><li><p><code>ln</code>指令</p><p>软链接也称为符号链接，类似于 windows 里的快捷方式，主要存放了链接其他文件的路径</p><p><code>ln -s [原文件目录] [软链接名]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s /root /home/myroot</span><br><span class="line">rm /home/myroot //删除软链接</span><br></pre></td></tr></table></figure></li><li><p><code>history</code>指令</p><p>查看已经执行过的历史命令，也可以执行历史指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">history //显示所有的历史指令</span><br><span class="line">history 10//显示最近10个使用过的指令</span><br><span class="line">!5//执行历史编号为5的指令</span><br></pre></td></tr></table></figure><p>执行历史编号指令，并不会在历史指令上添加该指令</p></li></ol><h4 id="7-4-时间日期"><a href="#7-4-时间日期" class="headerlink" title="7.4 时间日期"></a>7.4 时间日期</h4><ol><li><p><code>date</code>指令</p><p>显示当前日期</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">date //显示当前时间</span><br><span class="line">date +%Y//显示当前年份</span><br><span class="line">date &quot;+%Y-%m-%d %H:%M:%S&quot;//显示年月日时分秒</span><br></pre></td></tr></table></figure><p>date 指令还可以设置日期</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date -s &quot;2020-11-03 20:02:10&quot;</span><br></pre></td></tr></table></figure></li><li><p><code>cal</code>指令</p><p>查看日历指令，默认显示本月日历</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cal</span><br><span class="line">cal 2022//显示2022年日历</span><br></pre></td></tr></table></figure></li></ol><h4 id="7-5-搜索查找"><a href="#7-5-搜索查找" class="headerlink" title="7.5 搜索查找"></a>7.5 搜索查找</h4><ol><li><p><code>find</code>指令</p><p>find 指令将从指定目录向下递归地遍历其各个子目录，满足条件的文件或者目录将显示在中断。</p><p><code>find [搜索范围] [选项]</code></p><ul><li><p>按文件名</p><p><code>find /home -name hello.txt</code></p></li><li><p>按拥有者</p><p><code>find /opt -user root</code>：在 &#x2F;opt 目录下查找 root 用户的文件</p></li><li><p>按内存</p><p><code>find / -size +200M</code>：在根目录下查找大于200M的文件（加号表示大于），单位有 k，M，G</p></li></ul></li><li><p><code>locate</code>指令</p><p>该指令可以快速定位文件路径。但是locate指令的执行需要利用事先建立好的文件名称及路径的locate的数据库实现快速定位给定的文件（大概率是建立了一个树）。locate无需遍历整个文件系统，查询速度快。</p><p><code>locate 搜索文件</code></p><p>由于locate基于数据库进行查询，第一次运行前必须使用 <strong>updatedb</strong> 指令创建locate数据库</p></li><li><p><code>which</code>指令</p><p>查询某个指令在哪个目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which ls//查询ls指令在哪个目录下</span><br></pre></td></tr></table></figure></li><li><p><code>grep</code>指令和管道符号<code>|</code></p><p><strong>什么是管道符号</strong></p><p>将前一个指令的结果交给后一个指令处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /home/hello.txt | grep &quot;yes&quot;</span><br></pre></td></tr></table></figure><p>这一条指令表达的意思是浏览 &#x2F;home&#x2F;hello.txt 文件，然后交给 grep 处理，grep 的作用是查找 “yes” 所在行，如果要显示行号，加个 -n，-i表示忽略字母大小写</p><p>现在来单独看看 grep 怎么使用</p><p><code>grep [选项] 查找内容 源文件</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -n &quot;yes&quot; /home/hello.txt</span><br></pre></td></tr></table></figure></li></ol><h4 id="7-6-压缩解压"><a href="#7-6-压缩解压" class="headerlink" title="7.6 压缩解压"></a>7.6 压缩解压</h4><ol><li><p><code>gzip</code>&#x2F;<code>gunzip</code>指令</p><p>gzip 用于压缩文件，gunzip 用于解压</p><p><code>gzip filename</code>：压缩文件，只能将文件压缩为 .gz 格式</p><p><code>gunzip filename.gz</code>：解压缩文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gzip /home/hello.txt</span><br><span class="line">gunzip /home/hello.txt.gz</span><br></pre></td></tr></table></figure></li><li><p><code>zip</code>&#x2F;<code>unzip</code>指令</p><p><code>zip [选项] xxx.zip</code>：将要压缩的内容</p><p><code>unzip [选项] xxx.zip</code>：解压缩文件</p><p>-r：递归压缩，-d：指定解压后文件的存放目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zip -r myhome.zip /home///将home目录及其包含的文件和子文件夹都进行压缩</span><br><span class="line">unzip -d /opt/tmp /home/myhome.zip//将myhome.zip解压到/opt/tmp目录下</span><br></pre></td></tr></table></figure></li><li><p><code>tar</code>指令</p><p>tar 指令是打包指令，最后打包的文件是 .tar.gz 文件</p><p><code>tar [选项] xxx.tar.gz 打包的内容</code></p><p><img src="/2023/05/13/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221224104245476.png" alt="image-20221224104245476"></p><p>将 &#x2F;home&#x2F;pig.txt 和 &#x2F;home&#x2F;cat.txt 压缩成 pc.tar.gz</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zcvf pc.tar.gz /home/pig.txt /home/cat.txt</span><br></pre></td></tr></table></figure><p>将 pc.tar.gz 解压到 &#x2F;opt&#x2F;tmp2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf /home/pc.tar.gz -C /opt/tmp2</span><br></pre></td></tr></table></figure></li></ol><h3 id="8-组和权限"><a href="#8-组和权限" class="headerlink" title="8. 组和权限"></a>8. 组和权限</h3><p>在 Linux中每个用户必须属于一个组，不能独立于组外。</p><p>对于 Linux 每个文件&#x2F;目录，有三个相对概念</p><ul><li>所有者：即有用该文件的用户</li><li>所在组：该用户所在的组</li><li>其他组：该组之外的组</li></ul><p>Linux 文件&#x2F;目录会根据相对概念的不同而显示出不同的权限</p><h4 id="8-1-文件所有者"><a href="#8-1-文件所有者" class="headerlink" title="8.1 文件所有者"></a>8.1 文件所有者</h4><ol><li><p><code>ls -ahl</code>：查看文件的所有者</p><p>-a：隐藏文件也显示；-h：贴合人类的形式显示文件大小；-l：用列表的形式展示文件</p><p><img src="/2023/05/13/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221225153247761.png" alt="image-20221225153247761"></p><p>可以看到中间两排名字，第一个即是该文件&#x2F;目录的所有者；第二个是所在组</p></li><li><p><code>chown</code>：修改文件所有者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown tom apple.txt</span><br><span class="line">chown -R tom /home/test //该目录即内部所有内容的所有者都修改成tom</span><br></pre></td></tr></table></figure><p>注：修改文件所有者，其所在组并不会变</p></li></ol><h4 id="8-2-组的创建"><a href="#8-2-组的创建" class="headerlink" title="8.2 组的创建"></a>8.2 组的创建</h4><p><code>groupadd [组名]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd monster</span><br><span class="line">useradd -g monster fox//创建用户fox，放入到monster中</span><br></pre></td></tr></table></figure><h4 id="8-3-所在组"><a href="#8-3-所在组" class="headerlink" title="8.3 所在组"></a>8.3 所在组</h4><p>当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组</p><ol><li><p>查看文件&#x2F;目录所在组</p><p>即前面提到的<code>ls -ahl</code></p></li><li><p>修改文件&#x2F;目录所在组</p><p><code>chgrp [组名] [文件名]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chgrp cherry apple.txt</span><br><span class="line">chgrp -R cherry /home/test //该目录即内部所有内容的所有组都修改成cherry</span><br></pre></td></tr></table></figure></li><li><p>改变用户所在组</p><p>在添加用户时，可以指定将该用户添加到哪个组中，也可以用 root 的管理权限改变某个用户所在的组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -g newgroup username</span><br></pre></td></tr></table></figure></li></ol><h4 id="8-4-组的权限"><a href="#8-4-组的权限" class="headerlink" title="8.4 组的权限"></a>8.4 组的权限</h4><p>上面图片取一个下来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r--.  1  tom  root  0  12月 25 13:57  apple.txt</span><br></pre></td></tr></table></figure><p>现在看看前面十位<code>-rw-r--r--</code></p><p>第 0 位：确定文件类型</p><ul><li><code>-</code>：普通文件（即带后缀名）</li><li><code>l</code>：链接，相当于 windows 的快捷方式</li><li><code>d</code>：目录，即为文件夹</li><li><code>c</code>：字符设备文件，如鼠标、键盘</li><li><code>b</code>：块设备，如硬盘</li></ul><p>之后 9 位按照三个一组，分成三组，分别对应<strong>所有者（User）、所有组（Group）、其他用户（Other）</strong></p><p><strong>rwx权限详解</strong></p><p>对于文件来说：</p><ul><li>[r]：代表可读，查看</li><li>[w]：代表可写，但是不代表删除，<strong>删除一个文件的前提是对该文件所在的目录有写权限</strong></li><li>[x]：代表可执行</li></ul><p>对于目录来说：</p><ul><li>[r]：代表可读，可以 ls 查看内容</li><li>[w]：代表可写，可以修改，对目录内创建+删除+重命名目录</li><li>[x]：代表可执行，即可以 cd 进入该目录</li></ul><h4 id="8-5-权限修改"><a href="#8-5-权限修改" class="headerlink" title="8.5 权限修改"></a>8.5 权限修改</h4><p><strong>直接修改权限</strong></p><p>u：所有者；g：所有组；o：其他人；a：所有人，权限通过 + - &#x3D; 变更</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod u=rwx,g=rx,o=x 文件/目录名</span><br><span class="line">chmod g+w,o+r 文件/目录名</span><br><span class="line">chmod o-x 文件/目录名</span><br></pre></td></tr></table></figure><p><strong>通过数字变更权限</strong></p><p>r&#x3D;4, w&#x3D;2, x&#x3D;1, so rwx&#x3D;7</p><p>e.g. 将 &#x2F;home&#x2F;abc.txt 文件的权限修改成 rwxr-xr-x</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 755 /home/abc.txt</span><br></pre></td></tr></table></figure><h3 id="9-定时任务调度"><a href="#9-定时任务调度" class="headerlink" title="9. 定时任务调度"></a>9. 定时任务调度</h3><h4 id="9-1-crond任务调度"><a href="#9-1-crond任务调度" class="headerlink" title="9.1 crond任务调度"></a>9.1 crond任务调度</h4><h5 id="9-1-1-概述"><a href="#9-1-1-概述" class="headerlink" title="9.1.1 概述"></a>9.1.1 概述</h5><p>任务调度是指系统在某个时间执行的特定的命令或程序。</p><p>任务调度分类：</p><ol><li>系统工作：有些重要的工作必须周而复始地进行，如病毒扫描</li><li>个别用户工作：个别用户希望执行某些程序，比如对 MySQL 数据库的备份</li></ol><h5 id="9-1-2-语法"><a href="#9-1-2-语法" class="headerlink" title="9.1.2 语法"></a>9.1.2 语法</h5><p><code>crontab [选项]</code></p><ul><li>-e：编辑 crontab 定时任务</li><li>-l：查询 crontab 任务</li><li>-r：删除当前用户所有的 crontab 任务</li></ul><p>先设置 crontab 定时任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure><p>执行完上面指令后会进入一个文本编辑界面，此时输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/1 * * * * date &gt;&gt; /tmp/mydate.txt</span><br></pre></td></tr></table></figure><p>这里表示每过一分钟将当前时间写入 mydate.txt 文件中</p><p>总共有五个 *，分别表示</p><ul><li>一个小时当中的第几分钟</li><li>一天当中的第几小时</li><li>一个月当中的第几天</li><li>一年当中的几月</li><li>一周当中的星期几（0和7代表星期日）</li></ul><p>而有一些特殊符号</p><ul><li><code>*</code> 代表任何时间，比如第一个 * 表示一小时中每分钟都执行一次</li><li><code>,</code> 代表不连续时间，<code>0 8,12,16 * * *</code> 代表每天8：00，12：00，16：00</li><li><code>-</code> 代表连续时间，<code>0 5 * * 1-6</code> 代表周一到周六的 5：00 执行一次</li></ul><h4 id="9-2-at定时任务"><a href="#9-2-at定时任务" class="headerlink" title="9.2 at定时任务"></a>9.2 at定时任务</h4><p>at 命令是一次性定时计划任务，执行完一个任务就不再执行此任务了。在使用 at 命令的时候，一定要保证 atd 进程的启动，可以使用相关指令来查看。</p><p><code>ps -ef</code> ：查看当前所有进程，如果要过滤，则<code>ps -ef | grep atd</code></p><p>这里举个栗子</p><p><img src="/2023/05/13/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221227150246714.png" alt="image-20221227150246714"></p><p>第一行<code>at 15:05</code> 表示任务将要执行的时间；然后中断会弹出<code>at &gt;</code>输入要执行的命令；再输入<strong>两次</strong><code>Ctrl+D</code>，输入完后终端会显示该任务编号和将要执行的时间。</p><p><code>atq</code>：查询任务队列</p><p><code>atrm [编号]</code> ：删除某个编号的任务</p><p>再来个栗子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">at now + 2 minutes</span><br><span class="line">at&gt; my.sh</span><br></pre></td></tr></table></figure><p>表示两分钟后执行 my.sh 脚本</p><h3 id="10-磁盘分区和挂载"><a href="#10-磁盘分区和挂载" class="headerlink" title="10. 磁盘分区和挂载"></a>10. 磁盘分区和挂载</h3><p>Linux 无论有几个分区，分给哪一个目录使用，归根结底就只有一个根目录。Linux 中每个分区都是用来组成整个文件系统的一部分。Linux 采用了一种“载入”的处理方法。硬盘和磁盘可以看成一个东西。</p><h4 id="10-1-硬盘说明"><a href="#10-1-硬盘说明" class="headerlink" title="10.1 硬盘说明"></a>10.1 硬盘说明</h4><p>Linux 硬盘主要分为 IDE 硬盘和 SCSI 硬盘，目前基本上是 SCSI 硬盘，现在介绍一下 SCSI 硬盘在 Linux 下的分区情况</p><p>SCSI 硬盘标识为<code>sdx~</code>，sd 表示分区所在的设备类型，即 SCSI。x 为盘号，a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘，以此类推。<code>~</code> 代表分区，前四个分区用数字 1~4 表示，它们是主分区或扩展分区，从 5 开始就是逻辑分区</p><h4 id="10-2-查看硬盘挂载情况"><a href="#10-2-查看硬盘挂载情况" class="headerlink" title="10.2 查看硬盘挂载情况"></a>10.2 查看硬盘挂载情况</h4><p><code>lsblk</code></p><p><img src="/2023/05/13/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221227171659530.png" alt="image-20221227171659530"></p><p>可以看到，sda 磁盘分成了三个区，后面列出了每个区的大小和挂载到的目录，sdb 为后面新加的磁盘，后面会介绍如何新加磁盘</p><p><code>lsblk -l</code></p><p><img src="/2023/05/13/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221227171857787.png" alt="image-20221227171857787"></p><p>每个分区都有一个独一无二的 UUID</p><h4 id="10-3-增加新磁盘"><a href="#10-3-增加新磁盘" class="headerlink" title="10.3 增加新磁盘"></a>10.3 增加新磁盘</h4><p>增加新磁盘主要分为 5 个步骤，现在一一介绍</p><ol><li><p>虚拟机增加硬盘</p></li><li><p>分区命令</p><p><code>fdisk /dev/sdb</code>，输入该条指令后，就开始对 sdb 分区</p></li><li><p>格式化磁盘</p><p><code>mkfs -t ext4 /dev/sdb1</code></p><p>其中 ext4 是分区类型</p></li><li><p>挂载目录</p><p><code>mount [设备名称] [挂载目录]</code>，例如<code>mount /dev/sdb1 /newdisk</code>，同理，也会有取消挂载：<code>mount /dev/sdb1 /newdisk</code></p><p><strong>使用命令行挂载，重启后会失效！</strong></p></li><li><p>永久挂载</p><p>修改 &#x2F;etc&#x2F;fstab 实现挂载</p></li></ol><p>这里指介绍了大致步骤，部分具体操作没有列出，参考教程即可。</p><h4 id="10-4-查询磁盘情况"><a href="#10-4-查询磁盘情况" class="headerlink" title="10.4 查询磁盘情况"></a>10.4 查询磁盘情况</h4><p><strong>查询系统整体磁盘使用情况</strong></p><p><code>df -h</code></p><p><img src="/2023/05/13/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221227173043974.png" alt="image-20221227173043974"></p><p><strong>查询指定目录的磁盘占用情况</strong></p><p><code>du</code>：默认为当前目录</p><ul><li><code>-s</code>：指定目录占用大小汇总</li><li><code>-h</code>：带计量单位</li><li><code>-a</code>：含文件</li><li><code>--max-depth=1</code>：子目录深度</li><li><code>-c</code>：列出明细的同时，增加汇总值</li></ul><h4 id="10-5-实用工作指令"><a href="#10-5-实用工作指令" class="headerlink" title="10.5 实用工作指令"></a>10.5 实用工作指令</h4><ol><li><p>统计 &#x2F;opt 文件夹下文件的个数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /opt | grep &quot;^-&quot; | wc -l</span><br></pre></td></tr></table></figure><p>对上面这条语句作个解释：先以列表形式列出 &#x2F;opt 下的内容，管道传给 grep，grep是过滤器，取出开头为 - 的内容，然后在交给 wc 处理，计算总共有多少条</p></li><li><p>统计 &#x2F;opt 文件夹下目录的个数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /opt | grep &quot;^d&quot; | wc -l</span><br></pre></td></tr></table></figure></li><li><p>统计 &#x2F;opt 文件夹下文件的个数，包括子文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -lR /opt | grep &quot;^-&quot; | wc -l</span><br></pre></td></tr></table></figure><p>-R 表示递归地查找</p></li><li><p>统计 &#x2F;opt 文件夹下目录的个数，包括子文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -lR /opt | grep &quot;^d&quot; | wc -l</span><br></pre></td></tr></table></figure></li><li><p>以树状显示目录结构</p><p><code>tree [目录]</code>，如果没有 tree，使用<code>yum install tree</code>安装</p></li></ol><h3 id="11-网络配置（未写）"><a href="#11-网络配置（未写）" class="headerlink" title="11. 网络配置（未写）"></a>11. 网络配置（未写）</h3><p>这一块不是听的很懂，暂时空着</p><h3 id="12-进程管理"><a href="#12-进程管理" class="headerlink" title="12. 进程管理"></a>12. 进程管理</h3><p>在 Linux 中，每一个被执行的程序都被称为一个进程，每一个进程都分配一个 ID 号（pid，进程号）。程序本来是一段代码，加载到内存运行后，就成了进程</p><p>进程以两种方式存在，<strong>前台和后台</strong>，一般来说前台的进程与用户交互，此时前台把信息发给后台，后台则执行实际操作。</p><h4 id="12-1-显示进程"><a href="#12-1-显示进程" class="headerlink" title="12.1 显示进程"></a>12.1 显示进程</h4><p><code>ps</code> 命令是用来查看目前系统中有哪些正在执行以及它们执行的情况</p><p>现在输入 <code>ps -aux</code></p><p>-a 显示现行终端机下执行的进程（除了阶段作业领导者）-u 以用户为主的格式显示进程情况 ，-x 显示所有进程，不以终端机来区分</p><p><img src="/2023/05/13/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221231114238365.png" alt="image-20221231114238365"></p><ul><li>USER：用户名称</li><li>PID：进程号</li><li>%CPU：进程占用 CPU 的百分比</li><li>%MEM：进程占用物理内存百分比</li><li>VSZ：进程占用的虚拟内存大小（KB）</li><li>RSS：进程占用的物理内存大小（KB）</li><li>TTY：终端名称，缩写</li><li>STAT：进程状态，S 表示睡眠</li><li>START：进程的启动时间</li><li>TIME：进程占用 CPU 的总时间</li><li>COMMAND：启动进程所用的命令和参数</li></ul><p>应用举例：以全格式显示 sshd 相关的进程 -e 表示显示所有，-f 表示全格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep sshd</span><br></pre></td></tr></table></figure><h4 id="12-2-终止进程"><a href="#12-2-终止进程" class="headerlink" title="12.2 终止进程"></a>12.2 终止进程</h4><p>若是某个进程执行一半需要停止时，或是消耗了很大的系统资源，需要考虑停止该进程。使用 kill 命令来完成此项任务</p><p><code>kill [选项] [进程号]</code>：通过指定进程号来终止进程</p><p><code>killall [进程名称]</code>：通过进程名称终止进程</p><p>有时候我们终止一些比较重要的进程，系统会认为我们误操作，加个 -9 可以强制终止</p><h4 id="12-3-进程树"><a href="#12-3-进程树" class="headerlink" title="12.3 进程树"></a>12.3 进程树</h4><p><code>pstree [选项]</code>：更加直观地查看进程信息（主要是体现父子关系）</p><p>-p：显示进程的 PID，-u：显示进程所属的用户</p><p><img src="/2023/05/13/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221231120212291.png" alt="image-20221231120212291"></p><h4 id="12-4-服务管理"><a href="#12-4-服务管理" class="headerlink" title="12.4 服务管理"></a>12.4 服务管理</h4><p>服务（Service）的本质就是进程，但是是运行在后台的，通常会监听某个端口，等待其它程序的请求，比如（mysqld, sshd, firewalld  等），因此又称为守护进程。</p><h5 id="12-4-1-Service管理指令"><a href="#12-4-1-Service管理指令" class="headerlink" title="12.4.1 Service管理指令"></a>12.4.1 Service管理指令</h5><p>基本语法：<code>service [服务名] [start|stop|restart|reload|status]</code></p><p>由于 CentOS7 以后许多服务不再放到 service 下管理，而是 systemctl 下，我们对前者做个简略介绍，再介绍后者。</p><p>service 指令管理的服务在 &#x2F;etc&#x2F;init.d 目录下查看  </p><h5 id="12-4-2-开机流程"><a href="#12-4-2-开机流程" class="headerlink" title="12.4.2 开机流程"></a>12.4.2 开机流程</h5><p>开机-&gt;BIOS-&gt;&#x2F;boot-&gt;systemd进程-&gt;运行级别-&gt;运行级别对应的服务</p><h5 id="12-4-3-chkconfig指令"><a href="#12-4-3-chkconfig指令" class="headerlink" title="12.4.3 chkconfig指令"></a>12.4.3 chkconfig指令</h5><p>通过该指令可以给服务的各个运行级别设置自启动&#x2F;关闭</p><p>基本语法</p><ul><li><p><code>chkconfig --list</code>：查看服务开启状态</p></li><li><p><code>chkconfig [服务名] --list</code></p></li><li><p><code>chkconfig --level 5 服务名 on/off</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --level 3 network off</span><br></pre></td></tr></table></figure><p>表示设置 network 在运行级别3状态下自动关闭，<strong>chkconfig 重新设置服务后自启动或关闭，需要重启机器 reboot 生效</strong></p></li></ul><h5 id="12-4-4-systemctl管理指令"><a href="#12-4-4-systemctl管理指令" class="headerlink" title="12.4.4 systemctl管理指令"></a>12.4.4 systemctl管理指令</h5><p><code>systemctl [start|stop|restart|status] 服务名</code></p><p><strong>设置服务的自启动状态</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-unit-files [| grep 服务名]//查看服务开机启动状态，grep可以进行过滤</span><br><span class="line">systemctl enable 服务名</span><br><span class="line">systemctl disable 服务名</span><br><span class="line">systemctl is-enabled 服务名//查询某个服务是否是自启动的</span><br></pre></td></tr></table></figure><h5 id="12-4-5-防火墙相关指令"><a href="#12-4-5-防火墙相关指令" class="headerlink" title="12.4.5 防火墙相关指令"></a>12.4.5 防火墙相关指令</h5><ul><li><p>打开端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --add-port=端口号/协议</span><br></pre></td></tr></table></figure></li><li><p>关闭端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --remove-port=端口号/协议</span><br></pre></td></tr></table></figure></li><li><p>重新载入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure></li><li><p>查询端口是否开放</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --query-port=端口号/协议</span><br></pre></td></tr></table></figure></li></ul><h4 id="12-5-动态监控进程"><a href="#12-5-动态监控进程" class="headerlink" title="12.5 动态监控进程"></a>12.5 动态监控进程</h4><p><code>top</code> 和 <code>ps</code> 指令很相似，都用来显示正在执行的进程，但是 top 不断更新正在运行的进程</p><p><code>top [选项]</code>：-d 秒数，-i 使 top 不显示任何闲置或僵死进程，-p 通过指定监控进程ID来仅仅监控某个进程的状态</p><h4 id="12-6-监控网络状态"><a href="#12-6-监控网络状态" class="headerlink" title="12.6 监控网络状态"></a>12.6 监控网络状态</h4><p><code>netstat [选项]</code>：-an 按一定顺序排列输出，-p 显示哪个进程在调用  </p><h3 id="13-Shell编程"><a href="#13-Shell编程" class="headerlink" title="13. Shell编程"></a>13. Shell编程</h3><p>Shell 是一个命令行解释器，它为用户提供了一个向 Linux 内核发送请求一遍运行程序的界面系统级程序，用户可以用 Shell 来启动、挂起、停止甚至是编写一些程序</p><h4 id="13-1-Hello-world"><a href="#13-1-Hello-world" class="headerlink" title="13.1 Hello world"></a>13.1 Hello world</h4><p>写下第一个脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &quot;hello, world!&quot;</span><br></pre></td></tr></table></figure><p>第一行为脚本开头规范，第二行 echo 表示输出，类似于 Python 中的 print</p><p>写完这个脚本后用户还没有执行权限，有两种执行方法</p><ul><li>先赋予用户对它的执行权限，<code>chmod u+x filename.sh</code>，然后使用相对路径或绝对路径执行脚本</li><li>强制执行：<code>sh filename.sh</code>（后面也可以使用绝对路径）</li></ul><h4 id="13-2-变量"><a href="#13-2-变量" class="headerlink" title="13.2 变量"></a>13.2 变量</h4><p>Shell 中变量主要分为系统变量和用户自定义变量，系统变量有 <code>$HOME, $PWD, $SHELL, $USER</code>等等，还可以显示当前 shell 中所有变量：<code>set</code></p><p><strong>变量定义</strong></p><p>定义变量：变量名&#x3D;值；撤销变量：unset  变量名；声明静态变量：readonly 变量名&#x3D;值，静态变量不能 unset</p><p><strong>规则</strong></p><p>变量名称不能以数字开头，且等号两侧不能有空格。变量名称一般为大写，这是一个规范。</p><p><strong>命令返回的值</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A=`date`</span><br><span class="line">A=$(date)</span><br></pre></td></tr></table></figure><p>date 为输出当前时间指令，此时会把该值赋给 A，这两行为等价写法</p><p><strong>设置环境变量</strong></p><p>举个栗子：</p><ol><li><p>在 &#x2F;etc&#x2F;profile 文件中定义 CHERRY_HOME 环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export CHERRY_HOME=/home/cherry</span><br></pre></td></tr></table></figure></li><li><p>让该环境变量生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></li></ol><p>按照上述方式配置完成后，任何地方都可以访问到该环境变量（例如任何shell脚本等）</p><p><strong>位置参数变量</strong></p><p>当执行一个 shell 脚本时，如果希望获取到命令行的参数信息，则使用位置参数变量</p><ul><li><code>$n</code>：n 为数字，$0 代表命令行本身，$1-$9 代表第一个到第九个参数，对于十个以上参数，${10}，即用大括号包含</li><li><code>$*</code>：把所有参数看成一个整体</li><li><code>$@</code>：也代表所有参数，不过把每个参数区分对待</li><li><code>$#</code>：表示所有参数的个数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &quot;POS0=$0,POS1=$1,POS2=$2&quot;</span><br><span class="line">echo &quot;All parameter:$*&quot;</span><br><span class="line">echo &quot;$@&quot;</span><br><span class="line">echo &quot;$#&quot;</span><br></pre></td></tr></table></figure><p>运行该 shell 脚本输出情况为</p><p><img src="/2023/05/13/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230104111615769.png" alt="image-20230104111615769"></p><p><strong>预定义变量</strong></p><p>就是 shell 设计者预先定义好的变量，可以直接在 shell 脚本中使用</p><ul><li><code>$$</code>：当前进程的进程号（PID）</li><li><code>$!</code>：后台运行的最后一个进程的进程号</li><li><code>$?</code>：最后一次执行的命令的返回状态，如果值为 0，证明上一个命令正确运行</li></ul><h4 id="13-3-运算符"><a href="#13-3-运算符" class="headerlink" title="13.3 运算符"></a>13.3 运算符</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">RES1=$(((2+3)*4))</span><br><span class="line">RES2=$[(2+3)*4]</span><br><span class="line">TEMP=`expr 2 + 3`</span><br><span class="line">RES3=`expr $TEMP \* 4`</span><br></pre></td></tr></table></figure><p>上面个总共是三种写法，记第二种就可以了。。。</p><h4 id="13-4-判断"><a href="#13-4-判断" class="headerlink" title="13.4 判断"></a>13.4 判断</h4><ol><li>if 语句</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if [ &quot;ok&quot; = &quot;ok&quot; ]</span><br><span class="line">then</span><br><span class="line">echo &quot;equal&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>[ ] 内放判断条件，注意每个部分都要用空格隔开。</p><p>多条判断</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">if [ $1 -ge 60 ]</span><br><span class="line">then </span><br><span class="line">echo &quot;pass!&quot;</span><br><span class="line">elif [ $1 -lt 60 ]</span><br><span class="line">then </span><br><span class="line">echo &quot;no pass!&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><ol start="2"><li>case 语句</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">case $1 in</span><br><span class="line">&quot;1&quot;)</span><br><span class="line">echo &quot;Monday&quot;</span><br><span class="line">;;</span><br><span class="line">&quot;2&quot;)</span><br><span class="line">echo &quot;Tuesday&quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">echo &quot;other...&quot;</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><h4 id="13-5-循环"><a href="#13-5-循环" class="headerlink" title="13.5 循环"></a>13.5 循环</h4><ol><li><p>for 循环</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for i in &quot;$@&quot;</span><br><span class="line">do</span><br><span class="line">echo &quot;num is $i&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">SUM=0</span><br><span class="line">for((i=1;i&lt;=$1;i++))</span><br><span class="line">do</span><br><span class="line">SUM=$[$SUM+$i]</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>可以看到 for 循环有两种形式，第一种是 for in，遍历每一个值，第二种则和 c 语言的 for 很类似</p></li><li><p>while 循环</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">SUM=0</span><br><span class="line">i=0</span><br><span class="line">while [ $i -le $1 ]</span><br><span class="line">do</span><br><span class="line">SUM=$[$SUM+$i]</span><br><span class="line">i=$[$i+1]</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>从 0 加到 $1</p></li></ol><h4 id="13-6-输入"><a href="#13-6-输入" class="headerlink" title="13.6 输入"></a>13.6 输入</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read -p &quot;input number:&quot; NUM1</span><br><span class="line">read -t 10 -p &quot;input number:&quot; NUM2</span><br></pre></td></tr></table></figure><p>第一个表示输出提示信息，然后等待用户输入一个数字</p><p>第二个则多了 -t ，表示等待一定时间过后变不再等待</p><h4 id="13-7-函数"><a href="#13-7-函数" class="headerlink" title="13.7 函数"></a>13.7 函数</h4><p><strong>系统函数</strong></p><ul><li><code>basename</code>：输入一个完整路径，只返回文件名</li><li><code>dirname</code>：输入一个完整路径，值返回路径</li></ul><p><strong>自定义函数</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">function Sum()&#123;</span><br><span class="line">SUM=$[$1+$2]</span><br><span class="line">echo &quot;sum:$SUM&quot;</span><br><span class="line">&#125;</span><br><span class="line">read -p &quot;input1:&quot; n1</span><br><span class="line">read -p &quot;input2:&quot; n2</span><br><span class="line">Sum $n1 $n2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt学习笔记</title>
      <link href="/2023/05/07/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/05/07/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p> 基本完结，之后做项目的过程会不断进行补充~~~</p><h3 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h3><h4 id="1-1-创建项目"><a href="#1-1-创建项目" class="headerlink" title="1.1 创建项目"></a>1.1 创建项目</h4><p>打开 Qt Creator 后，创建新项目：</p><ol><li><p>选择 Application -&gt;Qt Widgets Application</p></li><li><p>指定项目地址和名称</p></li><li><p>Build System: qmake</p></li><li><p>Details</p><p>类信息，在这里面有三个基类供我们选择：</p><ul><li>QWidget：最简单的空白窗口。</li><li>QMainWindow：主窗口（包含了标题栏，菜单栏等）。</li><li>QDialog：对话框。</li></ul><p>下图展示了三个基类的继承关系</p><p><img src="/2023/05/07/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230505203809254-16837060006651.png" alt="image-20230505203809254"></p></li><li><p>Kits：我这里选择 MinGW。</p></li><li><p>Summary：这里可以选择版本控制系统，可以不选择。</p></li></ol><h4 id="1-2-文件结构介绍"><a href="#1-2-文件结构介绍" class="headerlink" title="1.2 文件结构介绍"></a>1.2 文件结构介绍</h4><p>项目创建完毕后，会生成一个 <code>.pro</code> 的项目文件和一些 <code>.h, .cpp</code> 的文件。</p><p><strong>main.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span><span class="comment">//包含一个应用程序类的头文件</span></span></span><br><span class="line"><span class="comment">//main程序入口  argc命令行变量的数量  argv命令行变量的数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//应用程序对象，有且仅有一个</span></span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    <span class="comment">//实例化对象widget</span></span><br><span class="line">    Widget w;</span><br><span class="line">    <span class="comment">//显示窗口</span></span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line">    <span class="comment">//应用程序进入消息循环</span></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>widget.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WIDGET_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIDGET_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT <span class="comment">//宏，允许类中使用信号和槽的机制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">Widget</span>(QWidget *parent = <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~<span class="built_in">Widget</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// WIDGET_H</span></span></span><br></pre></td></tr></table></figure><p><strong>widget.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;widget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)</span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)<span class="comment">//初始化列表</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget::~<span class="built_in">Widget</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-命名规范"><a href="#1-3-命名规范" class="headerlink" title="1.3 命名规范"></a>1.3 命名规范</h4><ul><li>类名：首字母大写，单词和单词之间首字母大写。</li><li>函数名  变量名称：首字母小写，单词和单词直接首字母大写。</li></ul><h4 id="1-4-常用快捷键"><a href="#1-4-常用快捷键" class="headerlink" title="1.4 常用快捷键"></a>1.4 常用快捷键</h4><ul><li>注释ctrl + &#x2F;</li><li>运行    ctrl + r</li><li>编译    ctrl + b</li><li>字体缩放    ctrl + 鼠标滚轮</li><li>整行移动    ctrl + shift + ↑ &#x2F; ↓</li><li>帮助文档    F1</li><li>自动对齐    ctrl + i</li><li>同名之间的 .h 和 .cpp 切换    F4</li></ul><h3 id="2-小试牛刀"><a href="#2-小试牛刀" class="headerlink" title="2. 小试牛刀"></a>2. 小试牛刀</h3><h4 id="2-1-窗口操作"><a href="#2-1-窗口操作" class="headerlink" title="2.1 窗口操作"></a>2.1 窗口操作</h4><p>这一节介绍一些窗口操作的 API。</p><p>在对窗口的属性进行设置时，往往在构造函数中完成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重置窗口大小</span></span><br><span class="line"><span class="built_in">resize</span>(<span class="number">600</span>, <span class="number">400</span>);</span><br><span class="line"><span class="comment">//固定窗口大小</span></span><br><span class="line"><span class="built_in">setFixedSize</span>(<span class="number">600</span>, <span class="number">400</span>);</span><br><span class="line"><span class="comment">//设置窗口标题</span></span><br><span class="line"><span class="built_in">setWindowTitle</span>(<span class="string">&quot;hello_Qt&quot;</span>);</span><br></pre></td></tr></table></figure><p>这些方法都是继承父类得来的，直接调用即可，如果想进一步增强可读性，可添加 this 指针，但在类方法调用的过程中，编译器已经为我们默认添加了 this 指针。</p><h4 id="2-2-QPushButton"><a href="#2-2-QPushButton" class="headerlink" title="2.2 QPushButton"></a>2.2 QPushButton</h4><p>该类表示按钮，是十分常用的控件之一，仍然实在构造函数中创建</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)<span class="comment">//构造函数</span></span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    QPushButton *btn = <span class="keyword">new</span> QPushButton;</span><br><span class="line">    btn-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码是错误的，<code>show()</code> 方法以顶层方式弹出窗口空间，因此会在另一个窗口中弹出按钮控件。现在要让 <code>btn</code> 依赖于 <code>QWidget</code> 窗口，需要把 <code>btn</code> 的父类对象设置为 <code>QWidget</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line">Widget::<span class="built_in">Widget</span>(QWidget *parent)<span class="comment">//构造函数</span></span><br><span class="line">    : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line">    QPushButton *btn1 = <span class="keyword">new</span> QPushButton;</span><br><span class="line">    btn1-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);</span><br><span class="line">    btn1-&gt;<span class="built_in">setText</span>(<span class="string">&quot;btn1&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    QPushButton *btn2 = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;btn2&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面通过两种方法创建按钮控件，都是可行的。</p><p> <strong>设置相关属性</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置父亲</span></span><br><span class="line">btn-&gt;<span class="built_in">setParent</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//设置按钮名称</span></span><br><span class="line">btn-&gt;<span class="built_in">setText</span>(<span class="string">&quot;btn&quot;</span>);</span><br><span class="line"><span class="comment">//移动按钮位置</span></span><br><span class="line">btn-&gt;<span class="built_in">move</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><h4 id="2-3-对象树"><a href="#2-3-对象树" class="headerlink" title="2.3 对象树"></a>2.3 对象树</h4><p>在每次创建一个对象时，都要指定一个父亲，而 <code>QObject</code> 是最顶端的对象，所有的子类对象都是由 <code>QObject</code> 派生而来。</p><ul><li>构造函数：由上往下执行，先执行 <code>QObject</code> 的构造函数，再执行其子类的，不断执行下去。</li><li>析构函数：父类在执行析构函数时需要释放自身，这是先会检查其属下的子类对象是否被释放，因此由上往下检查子类对象，而由下往上不断释放类对象。</li></ul><h4 id="2-4-坐标系"><a href="#2-4-坐标系" class="headerlink" title="2.4 坐标系"></a>2.4 坐标系</h4><p>Qt 中的坐标系以左上角为原点，向右为 x 正方向；向下为 y 正方向。</p><h4 id="2-5-信号和槽"><a href="#2-5-信号和槽" class="headerlink" title="2.5 信号和槽"></a>2.5 信号和槽</h4><h5 id="2-5-1-基本概念"><a href="#2-5-1-基本概念" class="headerlink" title="2.5.1 基本概念"></a>2.5.1 基本概念</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(btn, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;QWidget::close);</span><br></pre></td></tr></table></figure><p>该函数传入四个参数：信号的发送者（类实例对象），发送的信号（函数地址），信号的接收者（类实例对象），处理的槽函数（函数地址）。</p><p>上面的代码则实现了点击按钮控件关闭窗口的连接函数。</p><p><strong>松散耦合</strong></p><p>参数的前两者和后两者没有什么关联，是松散的，但通过 connect 函数耦合起来。</p><p><strong>click &amp; clicked</strong></p><p>初学者可能对这两个函数有困惑。就我自己的理解，click 表示的是按钮的点击动作，而 clicked 是执行了按钮点击函数触发的函数。因此点击按钮，出发的是 clicked 函数，如果上面的 clicked 函数写成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(btn, &amp;QPushButton::click, <span class="keyword">this</span>, &amp;QWidget::close);</span><br></pre></td></tr></table></figure><p>则没有反应。</p><p>假设现在有两个按键，我们对其建立 connect 连接来更好地理解两个函数的区别。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(btn1, &amp;QPushButton::clicked, btn2, &amp;QPushButton::click);</span><br><span class="line"><span class="built_in">connect</span>(btn2, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;QWidget::close);</span><br></pre></td></tr></table></figure><p>上面代码的逻辑是，btn1 出发点击事件，会导致 btn2 点击动作的执行，而 btn2 点击动作的执行又导致 btn2 点击事件的发生，进而触发窗口关闭函数的执行。</p><p>最终的效果是，无论点击哪一个按键，窗口都会关闭。</p><h5 id="2-5-2-自定义信号和槽"><a href="#2-5-2-自定义信号和槽" class="headerlink" title="2.5.2 自定义信号和槽"></a>2.5.2 自定义信号和槽</h5><ul><li>自定义信号：返回 void；需要声明，不需要实现；可以有参数，可以重载。</li><li>自定义槽函数：返回 void，需要声明，也需要实现；可以有参数，可以重载。</li></ul><p>出发信号关键字：<code>emit</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">emit <span class="title">signal</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h6 id="小案例实战"><a href="#小案例实战" class="headerlink" title="小案例实战"></a><strong>小案例实战</strong></h6><p>项目放在 tc_st 中</p><p>现在实现一个小案例，分别创建 <code>Teacher</code> 和 <code>Student</code> 对象，实现以下功能：</p><ul><li><code>Teacher</code> 发出 <code>hungry</code> 信号，<code>Student</code> 响应 <code>treat</code> 信号。</li><li>实现信号和槽的重载。</li></ul><p>信号和槽的重载后，这样写便会出现二义性，编译无法通过：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(tc, &amp;Teacher::hungry, st, &amp;Student::treat);</span><br></pre></td></tr></table></figure><p>需要根据函数重载的特性定义两个指针变量，指向我们需要的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (Teacher::*tcSignal)(QString) = &amp;Teacher::hungry;</span><br><span class="line"><span class="built_in">void</span> (Student::*stSignal)(Qstring) = &amp;Student::treat;</span><br><span class="line"><span class="built_in">connect</span>(tc, tcSignal, st, stSignal);</span><br></pre></td></tr></table></figure><p>槽函数执行时，其接收的参数通过信号传入，具体内容见拓展知识。</p><h5 id="2-5-3-拓展知识"><a href="#2-5-3-拓展知识" class="headerlink" title="2.5.3 拓展知识"></a>2.5.3 拓展知识</h5><ul><li><p>信号可以连接信号。</p></li><li><p>一个信号可以连接多个槽函数。</p></li><li><p>多个信号可以连接同一个槽函数。</p></li><li><p><strong>信号与槽的参数必须一一对应。</strong></p></li><li><p>信号的参数个数可以多余槽的参数个数。</p><p>对后面两条内容做点说明，槽函数接收的参数，对于信号函数来说在前面必须有相同的对应的参数，而信号函数后面参数多了也没事。对于一一对应的参数，传入信号函数时会被自动传入到槽中。</p></li></ul><p><strong>Qt4 版本的信号与槽</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(sz, <span class="built_in">SIGNAL</span>(<span class="built_in">hungry</span>()), tc, <span class="built_in">SLOT</span>(<span class="built_in">treat</span>()));</span><br></pre></td></tr></table></figure><h5 id="2-5-4-Lambda表达式"><a href="#2-5-4-Lambda表达式" class="headerlink" title="2.5.4 Lambda表达式"></a>2.5.4 Lambda表达式</h5><p> 这玩意长的很阴间，刚开始怎么都看不懂，但是现在看看其实很简单的一个小东西。</p><p>最简单的 Lambda 表达式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]()&#123;&#125;();</span><br></pre></td></tr></table></figure><p>当然，上述表达式什么也做不了，现在看看它的语法形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture](params) opt -&gt;ret &#123;body;&#125;();</span><br></pre></td></tr></table></figure><ul><li><p><code>[capture]</code> 对 lambda 表达式所在作用域变量的捕获。</p><p>[]：不捕获任何变量，[&#x3D;]：表示按值捕获变量，[&amp;]：按引用捕获变量</p><p>[&#x3D;, &amp;x]：按值捕获变量，但对于 x 是按引用捕获。</p></li><li><p><code>(params)</code>表示 lambda 的参数。</p></li><li><p><code>opt</code> 表示 lambda 的选项，比如 mutable，表示变量可以修改，如果不声明，则变量无法在 lambda 表达式中被修改。</p></li><li><p><code>-&gt;ret</code> 表示 lambda 的返回值。</p></li><li><p><code>&#123;body;&#125;</code> 表示函数体。</p></li><li><p><code>()</code> 最后的小括号则是函数的调用。</p></li></ul><p>使用 Lambda 表达式建立信号与槽：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(btn, &amp;QPushButton::clicked, <span class="keyword">this</span>, [=]()&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">close</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>事实上，使用 Lambda 表达式建立信号与槽还有许多好处，之后会慢慢体现。</p><h3 id="3-QMainWindow"><a href="#3-QMainWindow" class="headerlink" title="3. QMainWindow"></a>3. QMainWindow</h3><p>QMainWindow 继承于 QWidget，为用户提供主窗口程序的类，是许多应用程序的基础，正如我正在写的 Typora 主体，就可以被称为一个 QMainWindow。其包含：</p><ul><li>菜单栏（menu bar）</li><li>工具栏（tool bar）</li><li>铆接部件（dock widget）</li><li>状态栏（status bar）</li><li>中心部件（central widget）</li></ul><p><img src="/2023/05/07/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230506113228675-16837060006662.png" alt="image-20230506113228675"></p><p>现在分别介绍各个部件</p><h4 id="3-1-菜单栏"><a href="#3-1-菜单栏" class="headerlink" title="3.1 菜单栏"></a>3.1 菜单栏</h4><p><img src="/2023/05/07/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230506114234425-16837060006663.png" alt="image-20230506114234425"></p><p>现在我们想在 qMainWindow 中实现如图效果，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;QMenuBar&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建菜单栏对象</span></span><br><span class="line">QMenuBar *bar = <span class="built_in">menuBar</span>();</span><br><span class="line"><span class="comment">//将菜单栏放入主窗口中</span></span><br><span class="line"><span class="built_in">setMenuBar</span>(bar);</span><br><span class="line"><span class="comment">//创建菜单</span></span><br><span class="line">QMenu *fileMenu = bar-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;file&quot;</span>);</span><br><span class="line">QMenu *editMenu = bar-&gt;<span class="built_in">addMenu</span>(<span class="string">&quot;edit&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建菜单项</span></span><br><span class="line">QAction *buildAction = fileMenu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;build&quot;</span>);</span><br><span class="line"><span class="comment">//添加分割线</span></span><br><span class="line">fileMenu-&gt;<span class="built_in">addSeparator</span>();</span><br><span class="line">QAction *openAction = fileMenu-&gt;<span class="built_in">addAction</span>(<span class="string">&quot;open&quot;</span>);</span><br></pre></td></tr></table></figure><p>基本的思路就是 菜单栏 -&gt; 菜单 -&gt; QAction，注意，菜单栏只能有一个。</p><h4 id="3-2-工具栏"><a href="#3-2-工具栏" class="headerlink" title="3.2 工具栏"></a>3.2 工具栏</h4><p>工具栏可以有很多个，下面一段代码介绍了工具栏的创建和一些基本的 API：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QToolBar *toolBar = <span class="keyword">new</span> QToolBar;</span><br><span class="line"><span class="comment">//添加工具栏并设置默认左侧停靠</span></span><br><span class="line"><span class="built_in">addToolBar</span>(Qt::LeftToolBarArea, toolBar);</span><br><span class="line"><span class="comment">//只允许左右停靠</span></span><br><span class="line">toolBar-&gt;<span class="built_in">setAllowedAreas</span>(Qt::LeftToolBarArea | Qt::RightToolBarArea);</span><br><span class="line"><span class="comment">//不允许浮动</span></span><br><span class="line">toolBar-&gt;<span class="built_in">setFloatable</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">//不允许移动</span></span><br><span class="line">toolBar-&gt;<span class="built_in">setMovable</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>在学习菜单栏的时候，容易发现菜单栏先是包含菜单（QMenu），然后是在菜单中放入 QAction。工具栏则是直接放入 QAction。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">toolBar-&gt;<span class="built_in">addAction</span>(buildAction);</span><br><span class="line">toolBar-&gt;<span class="built_in">addAction</span>(openAction);</span><br></pre></td></tr></table></figure><p>可以看到，传入的参数正是菜单栏中已经有的 QAction，正可谓条条大道通罗马。</p><p>菜单栏还可以添加其他的控件，比如按钮控件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QPushButton *btn = <span class="keyword">new</span> QPushButton;</span><br><span class="line">toolBar-&gt;<span class="built_in">addWidget</span>(btn);</span><br></pre></td></tr></table></figure><p>需要注意的是，下面的代码是存在问题的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建控件时直接设置父亲为工具栏</span></span><br><span class="line">QPushButton *btn = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(toolBar);</span><br></pre></td></tr></table></figure><p>这样会导致控件默认在左上角显示，会覆盖掉原有的内容。</p><h4 id="3-3-状态栏"><a href="#3-3-状态栏" class="headerlink" title="3.3 状态栏"></a>3.3 状态栏</h4><p>状态栏往往在窗口的最下方，显示一些状态信息。最多只有一个状态栏。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建状态栏</span></span><br><span class="line">QStatusBar *stBar = <span class="keyword">new</span> QStatusBar;</span><br><span class="line"><span class="built_in">setStatusBar</span>(stBar);</span><br><span class="line"></span><br><span class="line">QLabel *label1 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;提示信息&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">QLabel *label2 = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;右侧提示信息&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将两个label放入状态栏中</span></span><br><span class="line">stBar-&gt;<span class="built_in">addWidget</span>(label1);</span><br><span class="line">stBar-&gt;<span class="built_in">addPermanentWidget</span>(label2);</span><br></pre></td></tr></table></figure><p>效果如下图</p><p><img src="/2023/05/07/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230507194637051.png" alt="image-20230507194637051"></p><h4 id="3-4-铆接部件"><a href="#3-4-铆接部件" class="headerlink" title="3.4 铆接部件"></a>3.4 铆接部件</h4><p>铆接部件可以有很多个。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QDockWidget *dockWidget = <span class="keyword">new</span> <span class="built_in">QDockWidget</span>(<span class="string">&quot;float&quot;</span>);</span><br><span class="line"><span class="built_in">addDockWidget</span>(Qt::TopDockWidgetArea, dockWidget);</span><br><span class="line"><span class="comment">//设置允许停靠范围</span></span><br><span class="line">dockWidget-&gt;<span class="built_in">setAllowedAreas</span>(Qt::TopDockWidgetArea | Qt::BottomDockWidgetArea);</span><br></pre></td></tr></table></figure><h4 id="3-5-中心部件"><a href="#3-5-中心部件" class="headerlink" title="3.5 中心部件"></a>3.5 中心部件</h4><p>中心部件只能有一个，这里设置中心部件为 QTextEdit，中心部件也可以是其他东西。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QTextEdit *textEdit = <span class="keyword">new</span> <span class="built_in">QTextEdit</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">setCentralWidget</span>(textEdit);</span><br></pre></td></tr></table></figure><p>QMainWindow 的内容就结束了，观察五个部分，可以知道唯一的部分用 set ，而可以有多个的部分用 add。</p><h3 id="4-添加资源文件"><a href="#4-添加资源文件" class="headerlink" title="4. 添加资源文件"></a>4. 添加资源文件</h3><p><img src="/2023/05/07/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230507195834191.png" alt="image-20230507195834191"></p><p>对于 QAtion 或其他东西，左边有个图片小图标，这种就是资源文件。现在我们要学习一下如何添加图片（好看的皮囊才是最重要的！）</p><h4 id="4-1-代码中添加"><a href="#4-1-代码中添加" class="headerlink" title="4.1 代码中添加"></a>4.1 代码中添加</h4><p>在这里省略了直接通过 ui 界面设置控件，很容易上手，但不容易记录下来，不再赘述。现在假设我们建立了一个 QAction，现在对其添加图标。</p><ol><li><p>将图片拷贝到项目位置下</p><p><code>img</code> 里面要存的就是我们的图片</p></li></ol><p><img src="/2023/05/07/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230507231129992.png" alt="image-20230507231129992"></p><ol start="2"><li><p>文件 -&gt; 新建文件或项目 -&gt; Qt -&gt; Qt Resource File</p><p>这个是专门管理资源文件的东西。我们命名为 <code>res</code></p></li><li><p>进入界面</p><p><img src="/2023/05/07/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230507231526231.png" alt="image-20230507231526231"></p><p>添加 -&gt; 前缀，前缀添加完毕后，直接在里面添加文件即可。</p></li></ol><p>最后是加载文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ui-&gt;actionNew-&gt;<span class="built_in">setIcon</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/img/aaa.jpg&quot;</span>));</span><br></pre></td></tr></table></figure><h4 id="4-2-在-UI-界面中添加"><a href="#4-2-在-UI-界面中添加" class="headerlink" title="4.2 在 UI 界面中添加"></a>4.2 在 UI 界面中添加</h4><p>对于某个控件，找到 icon，点击倒三角，选择资源，</p><p><img src="/2023/05/07/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230508212144784.png" alt="image-20230508212144784"></p><h3 id="5-对话框"><a href="#5-对话框" class="headerlink" title="5. 对话框"></a>5. 对话框</h3><h4 id="5-1-模态与非模态"><a href="#5-1-模态与非模态" class="headerlink" title="5.1 模态与非模态"></a>5.1 模态与非模态</h4><ul><li>模态对话框：不可以对其他窗口进行操作。</li><li>非模态对话框：可以对其他窗口进行操作。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(ui-&gt;actionNew, &amp;QAction::triggered, [=]()&#123;</span><br><span class="line">   QDialog <span class="built_in">dlg</span>(<span class="keyword">this</span>);</span><br><span class="line">   dlg.<span class="built_in">exec</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>代码中我们建立了一个信号与槽的连接，当新建按下时，lambda 表达式中创建了一个对话框，并以<strong>阻塞</strong>的方式显示在那里。</p><p>现在创建一个非模态的对话框：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(ui-&gt;actionNew, &amp;QAction::triggered, [=]()&#123;</span><br><span class="line">   QDialog <span class="built_in">dlg</span>(<span class="keyword">this</span>);</span><br><span class="line">   dlg.<span class="built_in">show</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但是这段代码是有问题的，lambda 函数执行完后，dlg 对象被销毁了，所以对话框只是一闪而过的形式。如果将 dlg 对象放到堆上，就可以解决：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(ui-&gt;actionNew, &amp;QAction::triggered, [=]()&#123;</span><br><span class="line">   QDialog *dlg = <span class="keyword">new</span> <span class="built_in">QDialog</span>(<span class="keyword">this</span>);</span><br><span class="line">   dlg.<span class="built_in">show</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然而这段代码还是有问题，我每次点击一下新建，就在堆创建了一个 dlg 对象，但是退出窗口后又不会删除这个对象，就会造成内存泄漏的问题。</p><p>添加如下代码即可解决：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dlg-&gt;<span class="built_in">setAttribute</span>(Qt::WA_DeleteOnClose);</span><br></pre></td></tr></table></figure><p>表示设置了窗口关闭后自动删除自身的属性。</p><h4 id="5-2-消息对话框"><a href="#5-2-消息对话框" class="headerlink" title="5.2 消息对话框"></a>5.2 消息对话框</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(ui-&gt;actionNew, &amp;QAction::triggered, [=]()&#123;</span><br><span class="line">    <span class="comment">//错误对话框</span></span><br><span class="line">    QMessageBox::<span class="built_in">critical</span>(<span class="keyword">this</span>, <span class="string">&quot;critical&quot;</span>, <span class="string">&quot;错误&quot;</span>);</span><br><span class="line">    <span class="comment">//信息对话框</span></span><br><span class="line">    QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="string">&quot;info&quot;</span>, <span class="string">&quot;信息&quot;</span>);</span><br><span class="line">    <span class="comment">//提问对话框</span></span><br><span class="line">    QMessageBox::<span class="built_in">question</span>(<span class="keyword">this</span>, <span class="string">&quot;ques&quot;</span>, <span class="string">&quot;提问&quot;</span>, QMessageBox::Save | QMessageBox::cancel);</span><br><span class="line">    <span class="comment">//警告对话框</span></span><br><span class="line">    QmessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>, <span class="string">&quot;warning&quot;</span>, <span class="string">&quot;警告&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>前三个都是基本的参数：父亲，标题，提示信息。</p><p>对于提问对话框，还需要额外传入一个按钮控件的信息，效果如图所示。</p><p><img src="/2023/05/07/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230508000734688.png" alt="image-20230508000734688"></p><p>如果用户点击了 <code>Save</code> ，程序怎么知道呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(QMessageBox::Save == QMessageBox::<span class="built_in">question</span>(<span class="keyword">this</span>, <span class="string">&quot;ques&quot;</span>, <span class="string">&quot;提问&quot;</span>, QMessageBox::Save | QMessageBox::cancel))&#123; </span><br><span class="line">    <span class="comment">//点击了Save后的一系列处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-颜色对话框"><a href="#5-3-颜色对话框" class="headerlink" title="5.3 颜色对话框"></a>5.3 颜色对话框</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QColor color = QColorDialog::<span class="built_in">getColor</span>(<span class="built_in">QColor</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>选择某个颜色后，返回 <code>QColor</code> 对象类型的数据，包含了四通道数等信息。</p><h4 id="5-4-文件对话框"><a href="#5-4-文件对话框" class="headerlink" title="5.4 文件对话框"></a>5.4 文件对话框</h4><p>这个对话框可能比较常用，基本就是选择了某个文件或文件夹后，返回被选择文件的路径，是一个 <code>QString</code> 类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QString str = QFileDialog::<span class="built_in">getOpenFileName</span>(<span class="keyword">this</span>, <span class="string">&quot;打开文件&quot;</span>, path);</span><br></pre></td></tr></table></figure><p>常用的几个参数：</p><p>参数1 - 父亲参数2 - 标题参数3 - 默认打开路径参数4 - 过滤文件格式。</p><h3 id="6-界面布局"><a href="#6-界面布局" class="headerlink" title="6. 界面布局"></a>6. 界面布局</h3><p>这一块主要设计 ui 操作，不太适合以文本的方式记录下来，这里放个实操视频。</p><p><a href="https://www.bilibili.com/video/BV1g4411H78N/?p=23&spm_id_from=pageDriver&vd_source=f72255f45500a180dd6d14464b11487b">界面布局-登录窗口</a></p><p>四大布局方式：</p><ul><li><p>水平布局：将控件水平排列。</p></li><li><p>垂直布局：将控件垂直排列。</p></li><li><p>栅格布局：以某个特定大小的矩阵进行布局。</p></li><li><p>嵌套布局：是以上几种布局的综合。</p><p>例如在 <code>QMainWindow</code> 中放入几个 <code>QWidget</code> 并垂直布局，然后对于每个 <code>QWdiget</code> 内部又可以放许多控件，使用不同的布局方式。</p></li></ul><h6 id="小案例实战-1"><a href="#小案例实战-1" class="headerlink" title="小案例实战"></a>小案例实战</h6><p>设计一个登录界面，用合理的布局，并加入弹簧控件。</p><p>项目文件已经放在 <code>example/login</code> 当中</p><h3 id="7-常用控件介绍"><a href="#7-常用控件介绍" class="headerlink" title="7. 常用控件介绍"></a>7. 常用控件介绍</h3><p>Qt 为我们提供的控件很多，不可能一下子学完，暂时介绍常用的，之后基本是用到了再来补充。</p><h4 id="7-1-按钮类"><a href="#7-1-按钮类" class="headerlink" title="7.1 按钮类"></a>7.1 按钮类</h4><h5 id="7-1-1-Push-Button"><a href="#7-1-1-Push-Button" class="headerlink" title="7.1.1 Push Button"></a>7.1.1 Push Button</h5><p>最常用的控件，不再多说。</p><h5 id="7-1-2-Tool-Button"><a href="#7-1-2-Tool-Button" class="headerlink" title="7.1.2 Tool Button"></a>7.1.2 Tool Button</h5><p>该控件可以看成是 Push Button 的升级版，比较适合添加图标，还可以设置透明等。</p><h5 id="7-1-3-Radio-Button"><a href="#7-1-3-Radio-Button" class="headerlink" title="7.1.3 Radio Button"></a>7.1.3 Radio Button</h5><p>该控件长这样：</p><p><img src="/2023/05/07/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230508213245964.png" alt="image-20230508213245964"></p><p>还可以用 <code>Containers</code> 中的 <code>Group Box</code> 将多个 <code>RadioButton</code> 放到一个组，这样每个组只有一个 <code>RadioButton</code> 会被选中。下图是一个小案例。</p><p><img src="/2023/05/07/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230508213628671.png" alt="image-20230508213628671"></p><h5 id="7-1-4-Check-Box"><a href="#7-1-4-Check-Box" class="headerlink" title="7.1.4 Check Box"></a>7.1.4 Check Box</h5><p><code>CheckBox</code> 和 <code>RadioButton</code> 差不多，圆圈变成了方框，但是放入 <code>Containers</code> 默认可以复选。</p><p><img src="/2023/05/07/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230508214204995.png" alt="image-20230508214204995"></p><h4 id="7-2-Item-Widgets"><a href="#7-2-Item-Widgets" class="headerlink" title="7.2 Item Widgets"></a>7.2 Item Widgets</h4><p>观察左边的控件栏，发现 Item Widgets 有两种，一个是 Model-Based，这种是基于数据库，我们一般用不上；另一种是 Item-Based，主要介绍这里面的控件。</p><h5 id="7-2-1-List-Widgets"><a href="#7-2-1-List-Widgets" class="headerlink" title="7.2.1 List Widgets"></a>7.2.1 List Widgets</h5><p>这个是显示文本的控件，但是它的每一行是 <code>QListWidgetItem</code> 对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QListWidgetitem *item = <span class="keyword">new</span> <span class="built_in">QListWidgetItem</span>(<span class="string">&quot;xxxxx&quot;</span>);</span><br><span class="line"><span class="comment">//将控件添加到listWidget中</span></span><br><span class="line">ui-&gt;listWidget-&gt;<span class="built_in">addItem</span>(item);</span><br><span class="line"><span class="comment">//设置文本在该行居中</span></span><br><span class="line">item-&gt;<span class="built_in">setTextAlignment</span>(Qt::AlignHCenter);</span><br></pre></td></tr></table></figure><p>它也可以一次性添加多行控件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QStringList list;</span><br><span class="line">list&lt;&lt;<span class="string">&quot;aaaaa&quot;</span>&lt;&lt;<span class="string">&quot;bbbbb&quot;</span>&lt;&lt;<span class="string">&quot;ccccc&quot;</span>;</span><br><span class="line">ui-&gt;listWidget-&gt;<span class="built_in">addItems</span>(list);</span><br></pre></td></tr></table></figure><p>重载了 <code>&lt;&lt;</code> 运算符还是很方便的。</p><h5 id="7-2-2-Tree-Widget"><a href="#7-2-2-Tree-Widget" class="headerlink" title="7.2.2 Tree Widget"></a>7.2.2 Tree Widget</h5><p><img src="/2023/05/07/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230508221319464.png" alt="image-20230508221319464"></p><h5 id="7-2-3-Tabel-Widget"><a href="#7-2-3-Tabel-Widget" class="headerlink" title="7.2.3 Tabel Widget"></a>7.2.3 Tabel Widget</h5><p><img src="/2023/05/07/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230508221642857.png" alt="image-20230508221642857"></p><p>还有许多控件就不说了，之后再来补档 QwQ</p><p><a href="https://www.bilibili.com/video/BV1g4411H78N?p=28&spm_id_from=pageDriver&vd_source=f72255f45500a180dd6d14464b11487b">其他常用控件介绍</a></p><p><img src="/2023/05/07/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230508221837397.png" alt="image-20230508221837397"></p><h3 id="8-自定义控件"><a href="#8-自定义控件" class="headerlink" title="8. 自定义控件"></a>8. 自定义控件</h3><p>Qt 的一大特色就是可以随意地进行控件的自定义封装，自己写一个可爱小巧又多功能的控件谁不爱呢？</p><p><strong>项目实战</strong></p><p>实现滑动条和值进行互联，如图所示，滑动条从左滑到右，左边数值从 0 到 100；修改左边的数值，滑动条也会移动。把这个东西封装成一个控件。</p><p><img src="/2023/05/07/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230509102732080.png" alt="image-20230509102732080"></p><p><strong>新建文件</strong></p><p>在新建文件或项目中选择 Qt -&gt; Qt 设计师界面类，命名时输入自己定义的类名，这里我取名 <code>MyWidget</code>，创建完毕后，在创建了 C++ 文件的同时，还有一个 <code>.ui</code> 的文件。</p><p><strong>控件设计与引入</strong></p><p>我们在生成的 <code>.ui</code> 文件中设计我们想要的控件即可。</p><p>接下来我们来到 <code>mainwindow.ui</code> 中，添加 <code>Widget</code> 控件，右键，选择 提升为 -&gt; 在 提升的类的名称 中输入我们自定义的控件类名即可，可以选择 全局包含。</p><p><strong>逻辑代码的编写</strong></p><p>之后，我们在 <code>mywidget.cpp</code> 的构造函数中进行逻辑代码的编写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置两者的范围</span></span><br><span class="line">ui-&gt;horizontalSlider-&gt;<span class="built_in">setRange</span>(<span class="number">1</span>,<span class="number">100</span>);</span><br><span class="line">ui-&gt;spinBox-&gt;<span class="built_in">setRange</span>(<span class="number">1</span>,<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//QSpinBox改变，QSlider跟着移动</span></span><br><span class="line"><span class="comment">//由于 valueChanged 有重载版本，故设置指针选择我们想要的版本</span></span><br><span class="line"><span class="built_in">void</span>(QSpinBox::* spSignal)(<span class="type">int</span>) = &amp;QSpinBox::valueChanged;</span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;spinBox, spSignal, ui-&gt;horizontalSlider, &amp;QSlider::setValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">//QSlider移动，QSpinBox跟着改变</span></span><br><span class="line"><span class="built_in">connect</span>(ui-&gt;horizontalSlider, &amp;QSlider::valueChanged, ui-&gt;spinBox, &amp;QSpinBox::setValue);</span><br></pre></td></tr></table></figure><h3 id="9-事件与定时器"><a href="#9-事件与定时器" class="headerlink" title="9. 事件与定时器"></a>9. 事件与定时器</h3><p>接下来这一章介绍 Qt 中的事件和定时器的使用，这两个东西非常非常重要。</p><p> 在 Qt 中，所有的事件都是继承自 <code>QEvent</code> 类，常见的事件有：鼠标事件、键盘事件、定时事件等。</p><p>对于事件的处理，就是重写一系列的 <code>Event</code> 函数，使得某个事件发生时，会跳转到我们重写的函数中。进行相关的处理。</p><h4 id="9-1-鼠标事件"><a href="#9-1-鼠标事件" class="headerlink" title="9.1 鼠标事件"></a>9.1 鼠标事件</h4><p>如果需要对事件做出一系列响应，就需要重写一个自定义控件。我们以 <code>QLabel</code> 为例，我们编写一个继承于它的自定义控件 <code>MyLabel</code>，当鼠标移入 <code>MyLabel</code> 或者移出，都显示响应的信息。</p><ol><li><p>新建 C++ 类，可以默认继承于 <code>QWidget</code>（反正之后都要改）。</p></li><li><p>在新建的类中重写两个事件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.h文件中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">enterEvent</span><span class="params">(QEvent *event)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">leaveEvent</span><span class="params">(QEvent *event)</span></span>;</span><br><span class="line"><span class="comment">//.c文件中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyLabel::enterEvent</span><span class="params">(QEvent *event)</span></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;鼠标进入了&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyLabel::leaveEvent</span><span class="params">(QEvent *event)</span></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;鼠标离开了&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>让 <code>MyLabel</code> 重新继承于 <code>QLabel</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.h文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QLabel&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLabel</span> : <span class="keyword">public</span> QLabel</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyLabel</span><span class="params">(QWidget *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//.c文件构造函数</span></span><br><span class="line">MyLabel::<span class="built_in">MyLabel</span>(QWidget *parent) : <span class="built_in">QLabel</span>(parent)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>现在看这段函数，发现有不少东西。</p><ul><li><code>MyLabel</code> 继承于 <code>QLabel</code> 。在构造函数中，用 <code>QWidget</code> 指向子类对象，并用初始化列表 <code>QLabel(parent)</code> 初始化 <code>QLabel</code> ，这一块的理解参考 《C++ Primer》 P557</li></ul></li><li><p>将 label 实例控件提升为我们自定义的类，并设置基类为 <code>QLabel</code></p></li></ol><p>现在我们再来介绍几个鼠标事件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyLabel::mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString str = <span class="built_in">QString</span>(<span class="string">&quot;鼠标按下了x=%1, y=%2&quot;</span>).<span class="built_in">arg</span>(event-&gt;<span class="built_in">x</span>()).<span class="built_in">arg</span>(event-&gt;<span class="built_in">y</span>());</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyLabel::mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">button</span>() == Qt::LeftButton)</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;鼠标释放了&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyLabel::mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">qDebug</span>()&lt;&lt;<span class="string">&quot;鼠标移动了&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置鼠标追踪状态</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setMouseTracking</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>说实话，事件这一块不是很懂，之后再补吧 QwQ</p><h4 id="9-2-定时器"><a href="#9-2-定时器" class="headerlink" title="9.2 定时器"></a>9.2 定时器</h4><h5 id="9-2-1-事件实现"><a href="#9-2-1-事件实现" class="headerlink" title="9.2.1 事件实现"></a>9.2.1 事件实现</h5><p>使用定时器的基本流程：启动一个定时器 -&gt; 重写定时器事件 -&gt; 每次定时器进入事件，进行相关处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MainWindow构造函数中，启动定时器</span></span><br><span class="line"><span class="built_in">startTimer</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写定时器事件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::timerEvent</span><span class="params">(QTimerEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    ui-&gt;label-&gt;<span class="built_in">setText</span>(QString::<span class="built_in">number</span>(num++));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想设置多个定时器，并对不同定时器的触发事件做出处理，应该怎么办？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">timerId1 = <span class="built_in">startTimer</span>(<span class="number">1000</span>);</span><br><span class="line">timerId2 = <span class="built_in">startTimer</span>(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::timerEvent</span><span class="params">(QTimerEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">timerId</span>() == timerId1)&#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">timerId</span>() == timerId2)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="9-2-2-信号与槽实现"><a href="#9-2-2-信号与槽实现" class="headerlink" title="9.2.2 信号与槽实现"></a>9.2.2 信号与槽实现</h5><p>这是定时器使用的另一种方法。创建一个定时器对象，并建立信号与槽监听定时器溢出状态，如果溢出就触发一次槽函数。而槽函数用 lambda 表达式实现较为方便。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QTimer *timer = <span class="keyword">new</span> <span class="built_in">QTimer</span>(<span class="keyword">this</span>);</span><br><span class="line">timer-&gt;<span class="built_in">start</span>(<span class="number">500</span>);</span><br><span class="line"><span class="built_in">connect</span>(timer, &amp;QTimer::timerout, [=]()&#123;</span><br><span class="line">   ... </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="9-3-事件分发器"><a href="#9-3-事件分发器" class="headerlink" title="9.3 事件分发器"></a>9.3 事件分发器</h4><p>APP 在下发事件时，都要先经过一个事件分发器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">event</span><span class="params">(QEvent *)</span></span>;</span><br></pre></td></tr></table></figure><p>我们可以在这里对事件进行拦截，代表用户要处理这个事件。</p><p>回到 <code>MyLabel</code> ，重写这个事件分发器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MyLabel::event</span><span class="params">(QEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e-&gt;<span class="built_in">type</span>() == QEvent::MouseButtonPress)&#123;</span><br><span class="line">        <span class="comment">//在使用该类型前先进行静态类型转换</span></span><br><span class="line">        QMouseEvent *ev = <span class="built_in">static_cast</span>&lt;QMouseEvent *&gt;(e);</span><br><span class="line">...</span><br><span class="line">        <span class="comment">//返回true，代表用户自己处理这个事件</span></span><br><span class="line">        <span class="keyword">return</span> ture;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他事件默认处理</span></span><br><span class="line">    <span class="keyword">return</span> QLabel::<span class="built_in">event</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2023/05/07/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/05/07/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>很早就有创建一个个人博客站的想法，但因为各种事情搁置了。这两天心血来潮，用 hexo 框架 + butterfly 主题临时赶工了一个出来。</p><p>至于创建博客站，主要是为了写一些技术类的文章，也灌水一些生活的牢骚。如果我的某一篇技术类的文章对你有帮助，我会很开心的 ^_^</p><h3 id="关于我："><a href="#关于我：" class="headerlink" title="关于我："></a>关于我：</h3><ul><li>就读于 <a href="https://www.uestc.edu.cn/">电子科技大学</a> <a href="https://www.sp.uestc.edu.cn/">物理学院</a> 电子信息科学与技术专业</li><li>立志成为嵌入式 Linux 工程师</li><li>机器人爱好者</li><li>ACM 算法爱好者</li><li>一个逐渐退坑的二刺螈 QwQ</li></ul>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
